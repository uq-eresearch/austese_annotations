// Generated by CoffeeScript 1.6.3
/*
** Annotator v1.2.8-dev-d71d52a
** https://github.com/okfn/annotator/
**
** Copyright 2012 Aron Carroll, Rufus Pollock, and Nick Stenning.
** Dual licensed under the MIT and GPLv3 licenses.
** https://github.com/okfn/annotator/blob/master/LICENSE
**
** Built at: 2014-01-20 05:13:05Z
*/



/*
//
*/

// Generated by CoffeeScript 1.6.3
(function() {
  var $, CharRange, calcNodeOffset, calcStrippedOffset, cleanText, fuzzyFindOffsetsFromText, removeChars, removeCharsGlobal, walkDom, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Annotator.Plugin.CharRangeSelection = (function(_super) {
    __extends(CharRangeSelection, _super);

    function CharRangeSelection() {
      _ref = CharRangeSelection.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    CharRangeSelection.prototype.events = {
      'annotationCreated': 'annotationCreated',
      'annotationsLoaded': 'annotationsLoaded'
    };

    CharRangeSelection.prototype.pluginInit = function() {
      if (!Annotator.supported()) {

      }
    };

    CharRangeSelection.prototype.annotationCreated = function(annotation) {
      var charRange, content, extraChars, offset, prefixStart, range, selectedText, suffixEnd;
      extraChars = 50;
      if (annotation.ranges == null) {
        return annotation;
      }
      content = cleanText(this.element.text());
      range = annotation.ranges[0].normalize(this.annotator.wrapper[0]);
      charRange = new CharRange();
      offset = charRange.offsetsFromNormalizedRange(this.annotator.wrapper[0], range);
      selectedText = cleanText(annotation.quote);
      prefixStart = offset.start - extraChars < 0 ? 0 : offset.start - extraChars;
      suffixEnd = offset.end + extraChars > content.length ? content.length : offset.end + extraChars;
      annotation.prefix = content.slice(prefixStart, offset.start);
      annotation.suffix = content.slice(offset.end, suffixEnd);
      annotation.startOffset = offset.start;
      annotation.endOffset = offset.end;
      return annotation;
    };

    CharRangeSelection.prototype.annotationsLoaded = function(annotations) {
      var annotation, h, _i, _j, _len, _len1, _ref1;
      for (_i = 0, _len = annotations.length; _i < _len; _i++) {
        annotation = annotations[_i];
        if (annotation.startOffset != null) {
          if ((annotation.ranges == null) || annotation.ranges.length === 0) {
            this._loadAnnotation(annotation);
          } else if (annotation.originalQuote !== annotation.text) {
            if (annotation.highlights != null) {
              _ref1 = annotation.highlights;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                h = _ref1[_j];
                $(h).replaceWith(h.childNodes);
              }
            }
            this._loadAnnotation(annotation);
          }
        }
      }
      return annotations;
    };

    CharRangeSelection.prototype._loadAnnotation = function(annotation) {
      var TEXT_NODE, head, offsets, range, selectedText;
      head = this.element[0];
      TEXT_NODE = 3;
      offsets = {
        start: annotation.startOffset,
        end: annotation.endOffset
      };
      range = new CharRange().createRangeFromOffsets(head, offsets);
      selectedText = range.toString().replace(/\s+/g, ' ').trim();
      if ((annotation.originalQuote != null) && annotation.originalQuote.replace(/\s+/g, ' ').trim() !== selectedText) {
        offsets = fuzzyFindOffsetsFromText(head, annotation.originalQuote, offsets.start);
        range = new CharRange().createRangeFromOffsets(head, offsets, false);
        selectedText = range.toString().replace(/\s+/g, ' ').trim();
        if ((annotation.originalQuote != null) && annotation.originalQuote.replace(/\s+/g, ' ').trim() !== selectedText) {
          console.log("PANIC: annotation is attached incorrectly. Should be: '" + annotation.originalQuote + "'. But is: '" + selectedText + "'", {
            range: range,
            annotation: annotation
          });
          return;
        } else {
          console.log("FUZZY MATCHED: " + annotation.originalQuote + " to offset: " + offsets.start);
        }
      }
      annotation.ranges = [];
      annotation.ranges.push(range);
      return this.annotator.setupAnnotation(annotation);
    };

    return CharRangeSelection;

  })(Annotator.Plugin);

  CharRange = (function() {
    var DOM_ANNOTATOR_IGNORE_ATTRIBUTE, TEXT_NODE;

    function CharRange() {}

    DOM_ANNOTATOR_IGNORE_ATTRIBUTE = 'annotator_ignore';

    TEXT_NODE = 3;

    CharRange.prototype.offsetsOfString = function(node, text) {
      var lastOffset, nodeOffset, offsets;
      offsets = {};
      nodeOffset = node.textContent.indexOf(text);
      lastOffset = node.textContent.lastIndexOf(text);
      if (nodeOffset !== lastOffset) {
        console.log("PANIC - multiple positions of text found");
      }
      offsets.start = calcStrippedOffset(node.textContent, nodeOffset);
      offsets.end = calcStrippedOffset(node.textContent, nodeOffset + text.length);
      return offsets;
    };

    CharRange.prototype.offsetsFromDomRange = function(node, range) {
      var normalizedRange;
      normalizedRange = new Range.BrowserRange(range).normalize(node);
      return this.offsetsFromNormalizedRange(node, normalizedRange);
    };

    CharRange.prototype.offsetsFromNormalizedRange = function(node, normalizedRange) {
      var charCount, findOffsets, offsets;
      offsets = {};
      charCount = 0;
      findOffsets = function(currNode) {
        if (typeof currNode.hasAttribute === "function" ? currNode.hasAttribute(DOM_ANNOTATOR_IGNORE_ATTRIBUTE) : void 0) {
          return false;
        }
        if (currNode.nodeType === TEXT_NODE) {
          if (currNode === normalizedRange.start) {
            offsets.start = charCount;
          }
          if (currNode === normalizedRange.end) {
            offsets.end = charCount + cleanText(currNode.textContent).length;
          }
          return charCount += cleanText(currNode.textContent).length;
        }
      };
      walkDom(node, findOffsets);
      return offsets;
    };

    CharRange.prototype.createRangeFromOffsets = function(node, offsets, stripSpaces) {
      var charCount, endOffset, findRange, range, startOffset;
      if (stripSpaces == null) {
        stripSpaces = true;
      }
      startOffset = offsets.start;
      endOffset = offsets.end;
      charCount = 0;
      range = document.createRange();
      findRange = function(currNode) {
        var endPosition, length, startPos;
        if (typeof currNode.hasAttribute === "function" ? currNode.hasAttribute(DOM_ANNOTATOR_IGNORE_ATTRIBUTE) : void 0) {
          return false;
        }
        if (charCount >= endOffset) {
          return false;
        }
        if (currNode.nodeType === TEXT_NODE) {
          if (stripSpaces) {
            length = cleanText(currNode.textContent).length;
          } else {
            length = currNode.textContent.length;
          }
          if (length + charCount > startOffset && charCount <= startOffset) {
            if (stripSpaces) {
              startPos = calcNodeOffset(currNode.textContent, startOffset - charCount);
            } else {
              startPos = startOffset - charCount;
            }
            range.setStart(currNode, startPos);
          }
          if (length + charCount >= endOffset && charCount <= endOffset) {
            if (stripSpaces) {
              endPosition = calcNodeOffset(currNode.textContent, endOffset - charCount, true);
            } else {
              endPosition = endOffset - charCount;
            }
            range.setEnd(currNode, endPosition);
          }
          return charCount += length;
        }
      };
      walkDom(node, findRange);
      return range;
    };

    return CharRange;

  })();

  calcNodeOffset = function(text, charOffset, endOffset) {
    var char, countIncludingSpaces, countSkippingSpaces, _i, _len;
    if (endOffset == null) {
      endOffset = false;
    }
    countSkippingSpaces = 0;
    for (countIncludingSpaces = _i = 0, _len = text.length; _i < _len; countIncludingSpaces = ++_i) {
      char = text[countIncludingSpaces];
      if (countSkippingSpaces === charOffset) {
        if (!removeChars.test(char) || endOffset) {
          return countIncludingSpaces;
        }
      }
      if (!removeChars.test(char)) {
        countSkippingSpaces++;
      }
    }
    return countIncludingSpaces;
  };

  calcStrippedOffset = function(text, unstrippedOffset) {
    var char, strippedOffset, unstrippedCount, _i, _len;
    strippedOffset = 0;
    unstrippedCount = 0;
    if (unstrippedOffset === unstrippedCount) {
      return strippedOffset;
    }
    for (_i = 0, _len = text.length; _i < _len; _i++) {
      char = text[_i];
      unstrippedCount++;
      if (!(removeChars.test(char))) {
        strippedOffset++;
      }
      if (unstrippedOffset === unstrippedCount) {
        return strippedOffset;
      }
    }
    return strippedOffset;
  };

  cleanText = function(text) {
    return text.replace(removeCharsGlobal, '');
  };

  removeChars = /[\n\s]/;

  removeCharsGlobal = /[\n\s]/g;

  walkDom = function(node, func) {
    var returnVal, _results;
    returnVal = func(node);
    if (returnVal === false) {
      return;
    }
    node = node.firstChild;
    _results = [];
    while (node) {
      walkDom(node, func);
      _results.push(node = node.nextSibling);
    }
    return _results;
  };

  fuzzyFindOffsetsFromText = function(node, pattern, loc) {
    var cloned_node, dmp, location, offsets, text;
    cloned_node = $(node).clone();
    cloned_node.find('[annotator_ignore="true"]').remove();
    text = cloned_node.text();
    dmp = new diff_match_patch();
    location = dmp.match_main(text, pattern, loc);
    offsets = {
      start: location,
      end: location + pattern.length
    };
    return offsets;
  };

  $ = Annotator.$;

}).call(this);

/*
//
*/

//@ sourceMappingURL=annotator.charrangeselection.map